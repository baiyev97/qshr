📚 数组理论基础
数组是非常基础的数据结构，面试中经常出现。虽然大多数数组题在思维上并不复杂，但实现时对代码掌控能力要求较高。

也就是说，想法简单，实现不易。

✅ 什么是数组？
数组是存放在连续内存空间上的相同类型数据的集合。

我们可以通过下标快速访问数组中的元素：

int arr[5] = {1, 2, 3, 4, 5};
cout << arr[0]; // 输出 1
📌 数组的两个关键特性
数组下标从 0 开始
数组的内存地址是连续的
正因为内存地址连续，数组在插入或删除元素时需要移动其他元素，这也是数组操作效率不高的原因之一。

🧹 删除数组中的元素
以删除下标为 3 的元素为例，后面的所有元素都需要往前移动一位：

原数组: [1, 2, 3, 4, 5]
删除 arr[3] 后: [1, 2, 3, 5, _]
这就是为什么数组的删除操作时间复杂度是 O(n)。

⚠️ 注意：数组的元素不能真正删除，只能通过覆盖来实现“删除”的效果。

🧮 一维 vs 二维数组的内存结构
✅ C++ 中的二维数组
在 C++ 中，二维数组的内存是 连续分布 的。

示例代码：
void test_arr() {
    int array[2][3] = {
        {0, 1, 2},
        {3, 4, 5}
    };
    cout << &array[0][0] << " " << &array[0][1] << " " << &array[0][2] << endl;
    cout << &array[1][0] << " " << &array[1][1] << " " << &array[1][2] << endl;
}
输出示例（地址为 16 进制）：
0x7ffee4065820 0x7ffee4065824 0x7ffee4065828
0x7ffee406582c 0x7ffee4065830 0x7ffee4065834
可以看到，内存地址是连续的，每个元素相差 4 个字节（int 类型）。

💡 在 16 进制中：

0x24 + 4 = 0x28
0x28 + 4 = 0x2c
0x2c + 4 = 0x30
这说明二维数组在内存中是线性排列的。

⚠️ Java 中的二维数组
Java 的二维数组本质上是 数组的数组，即每一行是一个独立的数组对象。

示例代码：
public static void test_arr() {
    int[][] arr = {
        {1, 2, 3},
        {3, 4, 5},
        {6, 7, 8},
        {9, 9, 9}
    };
    System.out.println(arr[0]);
    System.out.println(arr[1]);
    System.out.println(arr[2]);
    System.out.println(arr[3]);
}
输出示例：
[I@7852e922
[I@4e25154f
[I@70dea4e
[I@5c647e05
这些是每一行数组对象的地址（经过 JVM 编码后的哈希值），可以看出：

Java 的二维数组在内存中不是连续分布的，而是多个一维数组的组合。

🧠 总结
特性	C++	Java
是否连续内存	✅ 是	❌ 否
二维数组本质	多维数组	数组的数组
是否支持指针	✅ 支持	❌ 不支持
删除元素	只能覆盖	只能覆盖
📌 补充：vector vs array（C++）
array 是固定长度的数组，内存连续
vector 是动态数组，底层实现也是 array，但属于容器类，封装了自动扩容等功能
std::array<int, 5> arr = {1, 2, 3, 4, 5}; // 固定长度
std::vector<int> vec = {1, 2, 3, 4, 5};   // 动态长度
🔚 小结
数组是连续内存中的相同类型数据集合
插入/删除操作效率较低，需移动元素
C++ 的二维数组是连续的，Java 的不是
了解数组底层结构有助于更好地掌握算法题实现